using System;
using System.Configuration;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.Text;


namespace DateTimeExtension
{
    /// <summary>
    /// Date & Time Utility Methods
    /// </summary>
    public static class DateTimeUtil
    {
        enum EnumDateRangeType
        {
            Today,
            Yesterday,
            Week,
            WeekLast,
            Month,
            MonthLast,
            Quarter,
            Year,
        }

        #region TimeZone Retrieval

        /// <summary>
        /// Retrieves the timezone defined in the appSettings section with the key "TimeZone"
        /// </summary>
        public static TimeZoneInfo CurrentTimeZone
        {
            get
            {
                string timeZone;
                if (string.IsNullOrWhiteSpace(timeZone = ConfigurationManager.AppSettings["TimeZone"]))
                {
                    return TimeZoneInfo.Local;
                }
                return TimeZoneInfo.FindSystemTimeZoneById(timeZone.Trim());
            }
        }

        #endregion

        #region Custom Kuldeep Methods

        public static string GetTimeZoneList()
        {
            var sb = new StringBuilder();
            sb.Append("<dl>");
            foreach (TimeZoneInfo item in TimeZoneInfo.GetSystemTimeZones())
            {
                sb.AppendFormat("<dt>{0}</dt>", item.Id);
                sb.AppendFormat("<dd>{0}</dd>", item.DisplayName);
            }
            sb.Append("</dl>");
            return sb.ToString();
        }

        public static DateTime ToLocalDateTime(this DateTime currentDateTime)
        {
            return Convert.ToDateTime(currentDateTime.ToString(DateTimeUtil.CurrentTimeZone));
        }

        public static DateTime ToLocalDate(this DateTime currentDateTime)
        {
            return currentDateTime.ToLocalDateTime().Date;
        }

        public static DateTime GetWeekStartDate(this DateTime baseDate, DayOfWeek startOfWeek = DayOfWeek.Monday)
        {
            return baseDate.GetRange(EnumDateRangeType.Week, startOfWeek)[0];
        }

        public static DateTime GetWeekEndDate(this DateTime baseDate, DayOfWeek startOfWeek = DayOfWeek.Monday)
        {
            return baseDate.GetRange(EnumDateRangeType.Week, startOfWeek)[1];
        }

        public static DateTime GetPreviousWeekStartDate(this DateTime baseDate, DayOfWeek startOfWeek = DayOfWeek.Monday)
        {
            return baseDate.GetRange(EnumDateRangeType.WeekLast, startOfWeek)[0];
        }

        public static DateTime GetPreviousWeekEndDate(this DateTime baseDate, DayOfWeek startOfWeek = DayOfWeek.Monday)
        {
            return baseDate.GetRange(EnumDateRangeType.WeekLast, startOfWeek)[1];
        }

        public static DateTime GetMonthStartDate(this DateTime baseDate)
        {
            return baseDate.GetRange(EnumDateRangeType.Month)[0];
        }

        public static DateTime GetMonthEndDate(this DateTime baseDate)
        {
            return baseDate.GetRange(EnumDateRangeType.Month)[1];
        }

        public static DateTime GetPreviousMonthStartDate(this DateTime baseDate)
        {
            return baseDate.GetRange(EnumDateRangeType.MonthLast)[0];
        }

        public static DateTime GetPreviousMonthEndDate(this DateTime baseDate)
        {
            return baseDate.GetRange(EnumDateRangeType.MonthLast)[1];
        }

        public static DateTime GetQuarterStartDate(this DateTime baseDate)
        {
            return baseDate.GetRange(EnumDateRangeType.Quarter)[0];
        }

        public static DateTime GetQuarterEndDate(this DateTime baseDate)
        {
            return baseDate.GetRange(EnumDateRangeType.Quarter)[1];
        }

        public static DateTime GetYearStartDate(this DateTime baseDate)
        {
            return baseDate.GetRange(EnumDateRangeType.Year)[0];
        }

        public static DateTime GetYearEndDate(this DateTime baseDate)
        {
            return baseDate.GetRange(EnumDateRangeType.Year)[1];
        }

        private static DateTime[] GetRange(this DateTime baseDate, EnumDateRangeType dateRangeType = EnumDateRangeType.Week, DayOfWeek startOfWeek = DayOfWeek.Monday)
        {
            var result = new DateTime[2];
            DateTime dateRangeBegin = baseDate;
            DateTime dateRangeEnd = baseDate;
            baseDate = baseDate.Date;

            var today = baseDate;
            var yesterday = baseDate.AddDays(-1);
            //var thisWeekStart = baseDate.AddDays(-(int)(baseDate.DayOfWeek - startOfWeek));
            var thisWeekStart = baseDate.CalculateStartOfWeek(startOfWeek);
            var thisWeekEnd = thisWeekStart.AddDays(6);
            var lastWeekStart = thisWeekStart.AddDays(-7);
            var lastWeekEnd = thisWeekStart.AddDays(-1);
            var thisMonthStart = baseDate.AddDays(1 - baseDate.Day);
            var thisMonthEnd = thisMonthStart.AddMonths(1).AddDays(-1);
            var lastMonthStart = thisMonthStart.AddMonths(-1);
            var lastMonthEnd = thisMonthStart.AddDays(-1);

            int currentQuarterNo = (baseDate.Date.Month - 1) / 3 + 1;
            int daysInLastMonthOfCurrentQuarter = DateTime.DaysInMonth(baseDate.Year, 3 * currentQuarterNo);
            var thisQuarterStart = new DateTime(baseDate.Year, 3 * currentQuarterNo - 2, 1);
            var thisQuarterEnd = new DateTime(baseDate.Year, 3 * currentQuarterNo, daysInLastMonthOfCurrentQuarter);

            var thisYearStart = new DateTime(baseDate.Year, 1, 1);
            var thisYearEnd = new DateTime(baseDate.Year, 12, 31);

            switch (dateRangeType)
            {
                case EnumDateRangeType.Today:
                    dateRangeBegin = dateRangeEnd = today;
                    break;
                case EnumDateRangeType.Yesterday:
                    dateRangeBegin = dateRangeEnd = yesterday;
                    break;
                case EnumDateRangeType.Week:
                    dateRangeBegin = thisWeekStart;
                    dateRangeEnd = thisWeekEnd;
                    break;
                case EnumDateRangeType.WeekLast:
                    dateRangeBegin = lastWeekStart;
                    dateRangeEnd = lastWeekEnd;
                    break;
                case EnumDateRangeType.Month:
                    dateRangeBegin = thisMonthStart;
                    dateRangeEnd = thisMonthEnd;
                    break;
                case EnumDateRangeType.MonthLast:
                    dateRangeBegin = lastMonthStart;
                    dateRangeEnd = lastMonthEnd;
                    break;
                case EnumDateRangeType.Quarter:
                    dateRangeBegin = thisQuarterStart;
                    dateRangeEnd = thisQuarterEnd;
                    break;
                case EnumDateRangeType.Year:
                    dateRangeBegin = thisYearStart;
                    dateRangeEnd = thisYearEnd;
                    break;
            }

            result[0] = dateRangeBegin.Date;
            result[1] = dateRangeEnd.Date;
            return result;
        }

        private static DateTime CalculateStartOfWeek(this DateTime dt, DayOfWeek startOfWeek)
        {
            int diff = dt.DayOfWeek - startOfWeek;
            if (diff < 0)
            {
                diff += 7;
            }
            return dt.AddDays(-1 * diff).Date;
        }
        public static int CalculateAge(this DateTime dateOfBirth)
        {
            return dateOfBirth.CalculateAge(DateTime.Now.ToLocalDate());
        }

        public static int CalculateAge(this DateTime dateOfBirth, DateTime referenceDate)
        {
            int year = referenceDate.Year - dateOfBirth.Year;
            if (referenceDate.Month < dateOfBirth.Month || referenceDate.Month == dateOfBirth.Month && referenceDate.Day < dateOfBirth.Day)
            {
                year--;
            }
            return year;
        }

        public static bool Between(this DateTime dt, DateTime rangeBeg, DateTime rangeEnd)
        {
            return dt.Ticks >= rangeBeg.Ticks && dt.Ticks <= rangeEnd.Ticks;
        }

        public static bool IsDateEqual(this DateTime date, DateTime dateToCompare)
        {
            return date.Date == dateToCompare.Date;
        }
        #endregion

        #region DateTime to String Conversion

        /// <summary>
        /// Formats a date/time object to the specified time zone
        /// </summary>
        /// <param name="dateTime">Date/Time to convert</param>
        /// <param name="timeZone">Destination time zone</param>
        /// <param name="format">Format</param>
        /// <param name="formatProvider">Formatting provider</param>
        /// <returns>Textual representation of the date/time in the specified timezone</returns>
        public static string ToString(this DateTime dateTime, TimeZoneInfo timeZone, string format = null, IFormatProvider formatProvider = null)
        {
            if (timeZone == null)
            {
                timeZone = TimeZoneInfo.Local;
            }
            if (formatProvider == null)
            {
                formatProvider = CultureInfo.CurrentCulture;
            }

            // Convert to the specified time zone
            dateTime = TimeZoneInfo.ConvertTime(dateTime, timeZone);

            // Format
            if (format == null)
            {
                return dateTime.ToString(formatProvider);
            }
            else
            {
                return dateTime.ToString(format, formatProvider);
            }
        }

        #endregion

        #region Time Zone Text to UTC DateTime Parsing

        #region Normal Parsing

        /// <summary>
        /// Parses the specified text in the specified timezone
        /// </summary>
        /// <param name="timeZone">Time zone for which the text date is specified</param>
        /// <param name="text">Date/time text to be parsed</param>
        /// <param name="formatProvider">Formatting culture</param>
        /// <param name="styles">DateTime styles</param>
        /// <returns>DateTime object in Utc co-ordinates</returns>
        public static DateTime ParseToUtcTime(this TimeZoneInfo timeZone, string text, IFormatProvider formatProvider = null, DateTimeStyles styles = DateTimeStyles.None)
        {
            if (timeZone == null)
            {
                timeZone = TimeZoneInfo.Local;
            }
            if (text == null)
            {
                throw new ArgumentNullException("text");
            }
            if (formatProvider == null)
            {
                formatProvider = CultureInfo.CurrentCulture;
            }

            return TimeZoneInfo.ConvertTimeToUtc(DateTime.SpecifyKind(DateTime.Parse(text, formatProvider, styles), DateTimeKind.Unspecified), timeZone);
        }

        /// <summary>
        /// Tries to parse the specified text in the specified timezone
        /// </summary>
        /// <param name="timeZone">Time zone for which the text date is specified</param>
        /// <param name="text">Date/time text to be parsed</param>
        /// <param name="utcTime">Parsed time</param>
        /// <param name="formatProvider">Formatting culture</param>
        /// <param name="styles">DateTime styles</param>
        /// <returns>True if the text could be parsed. False otherwise</returns>
        [SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes")]
        public static bool TryParseToUtcTime(this TimeZoneInfo timeZone, string text, out DateTime utcTime, IFormatProvider formatProvider = null, DateTimeStyles styles = DateTimeStyles.None)
        {
            if (timeZone == null)
            {
                timeZone = TimeZoneInfo.Local;
            }
            if (text == null)
            {
                throw new ArgumentNullException("text");
            }
            if (formatProvider == null)
            {
                formatProvider = CultureInfo.CurrentCulture;
            }

            if (DateTime.TryParse(text, formatProvider, styles, out utcTime))
            {
                try
                {
                    TimeZoneInfo.ConvertTimeToUtc(DateTime.SpecifyKind(utcTime, DateTimeKind.Unspecified), timeZone);
                    return true;
                }
                catch
                {
                }
            }
            return false;
        }

        #endregion

        #region Exact Parsing

        /// <summary>
        /// Parses the specified text in the specified timezone
        /// </summary>
        /// <param name="timeZone">Time zone for which the text date is specified</param>
        /// <param name="text">Date/time text to be parsed</param>
        /// <param name="format">Date time format</param>
        /// <param name="formatProvider">Formatting culture</param>
        /// <param name="styles">DateTime styles</param>
        /// <returns>DateTime object in Utc co-ordinates</returns>
        public static DateTime ParseExactToUtcTime(this TimeZoneInfo timeZone, string text, string format, IFormatProvider formatProvider = null, DateTimeStyles styles = DateTimeStyles.None)
        {
            if (timeZone == null)
            {
                timeZone = TimeZoneInfo.Local;
            }
            if (text == null)
            {
                throw new ArgumentNullException("text");
            }
            if (format == null)
            {
                throw new ArgumentNullException("format");
            }
            if (formatProvider == null)
            {
                formatProvider = CultureInfo.CurrentCulture;
            }

            return TimeZoneInfo.ConvertTimeToUtc(DateTime.SpecifyKind(DateTime.ParseExact(text, format, formatProvider, styles), DateTimeKind.Unspecified), timeZone);
        }

        /// <summary>
        /// Tries to parse the specified text in the specified timezone
        /// </summary>
        /// <param name="timeZone">Time zone for which the text date is specified</param>
        /// <param name="text">Date/time text to be parsed</param>
        /// <param name="format">Date time format</param>
        /// <param name="utcTime">Parsed time</param>
        /// <param name="formatProvider">Formatting culture</param>
        /// <param name="styles">DateTime styles</param>
        /// <returns>True if the text could be parsed. False otherwise</returns>
        [SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes")]
        public static bool TryParseExactToUtcTime(this TimeZoneInfo timeZone, string text, string format, out DateTime utcTime, IFormatProvider formatProvider = null, DateTimeStyles styles = DateTimeStyles.None)
        {
            if (timeZone == null)
            {
                timeZone = TimeZoneInfo.Local;
            }
            if (text == null)
            {
                throw new ArgumentNullException("text");
            }
            if (format == null)
            {
                throw new ArgumentNullException("format");
            }
            if (formatProvider == null)
            {
                formatProvider = CultureInfo.CurrentCulture;
            }

            if (DateTime.TryParseExact(text, format, formatProvider, styles, out utcTime))
            {
                try
                {
                    TimeZoneInfo.ConvertTimeToUtc(DateTime.SpecifyKind(utcTime, DateTimeKind.Unspecified), timeZone);
                    return true;
                }
                catch
                {
                }
            }
            return false;
        }

        /// <summary>
        /// Parses the specified text in the specified timezone
        /// </summary>
        /// <param name="timeZone">Time zone for which the text date is specified</param>
        /// <param name="text">Date/time text to be parsed</param>
        /// <param name="formats">Date time formats to try</param>
        /// <param name="formatProvider">Formatting culture</param>
        /// <param name="styles">DateTime styles</param>
        /// <returns>DateTime object in Utc co-ordinates</returns>
        public static DateTime ParseExactToUtcTime(this TimeZoneInfo timeZone, string text, string[] formats, IFormatProvider formatProvider = null, DateTimeStyles styles = DateTimeStyles.None)
        {
            if (timeZone == null)
            {
                timeZone = TimeZoneInfo.Local;
            }
            if (text == null)
            {
                throw new ArgumentNullException("text");
            }
            if (formats == null)
            {
                throw new ArgumentNullException("formats");
            }
            if (formatProvider == null)
            {
                formatProvider = CultureInfo.CurrentCulture;
            }

            return TimeZoneInfo.ConvertTimeToUtc(DateTime.SpecifyKind(DateTime.ParseExact(text, formats, formatProvider, styles), DateTimeKind.Unspecified), timeZone);
        }

        /// <summary>
        /// Tries to parse the specified text in the specified timezone
        /// </summary>
        /// <param name="timeZone">Time zone for which the text date is specified</param>
        /// <param name="text">Date/time text to be parsed</param>
        /// <param name="formats">Date time formats to try</param>
        /// <param name="utcTime">Parsed time</param>
        /// <param name="formatProvider">Formatting culture</param>
        /// <param name="styles">DateTime styles</param>
        /// <returns>True if the text could be parsed. False otherwise</returns>
        [SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes")]
        public static bool TryParseExactToUtcTime(this TimeZoneInfo timeZone, string text, string[] formats, out DateTime utcTime, IFormatProvider formatProvider = null, DateTimeStyles styles = DateTimeStyles.None)
        {
            if (timeZone == null)
            {
                timeZone = TimeZoneInfo.Local;
            }
            if (text == null)
            {
                throw new ArgumentNullException("text");
            }
            if (formats == null)
            {
                throw new ArgumentNullException("formats");
            }
            if (formatProvider == null)
            {
                formatProvider = CultureInfo.CurrentCulture;
            }

            if (DateTime.TryParseExact(text, formats, formatProvider, styles, out utcTime))
            {
                try
                {
                    TimeZoneInfo.ConvertTimeToUtc(DateTime.SpecifyKind(utcTime, DateTimeKind.Unspecified), timeZone);
                    return true;
                }
                catch
                {
                }
            }
            return false;
        }

        #endregion

        #endregion

        #region Tme Zone Text to Local DateTime Parsing

        #region Normal Parsing

        /// <summary>
        /// Parses the specified text in the specified timezone
        /// </summary>
        /// <param name="timeZone">Time zone for which the text date is specified</param>
        /// <param name="text">Date/time text to be parsed</param>
        /// <param name="formatProvider">Formatting culture</param>
        /// <param name="styles">DateTime styles</param>
        /// <returns>DateTime object in Local co-ordinates</returns>
        public static DateTime ParseToLocalTime(this TimeZoneInfo timeZone, string text, IFormatProvider formatProvider = null, DateTimeStyles styles = DateTimeStyles.None)
        {
            return ParseToUtcTime(timeZone, text, formatProvider, styles).ToLocalTime();
        }

        /// <summary>
        /// Tries to parses the specified text in the specified timezone
        /// </summary>
        /// <param name="timeZone">Time zone for which the text date is specified</param>
        /// <param name="text">Date/time text to be parsed</param>
        /// <param name="localTime">Parsed time</param>
        /// <param name="formatProvider">Formatting culture</param>
        /// <param name="styles">DateTime styles</param>
        /// <returns>True if the text could be parsed. False otherwise</returns>
        public static bool TryParseToLocalTime(this TimeZoneInfo timeZone, string text, out DateTime localTime, IFormatProvider formatProvider = null, DateTimeStyles styles = DateTimeStyles.None)
        {
            if (TryParseToUtcTime(timeZone, text, out localTime, formatProvider, styles))
            {
                localTime = localTime.ToLocalTime();
                return true;
            }
            return false;
        }

        #endregion

        #region Exact Parsing

        /// <summary>
        /// Parses the specified text in the specified timezone
        /// </summary>
        /// <param name="timeZone">Time zone for which the text date is specified</param>
        /// <param name="text">Date/time text to be parsed</param>
        /// <param name="format">DateTime format</param>
        /// <param name="formatProvider">Formatting culture</param>
        /// <param name="styles">DateTime styles</param>
        /// <returns>DateTime object in Local co-ordinates</returns>
        public static DateTime ParseExactToLocalTime(this TimeZoneInfo timeZone, string text, string format, IFormatProvider formatProvider = null, DateTimeStyles styles = DateTimeStyles.None)
        {
            return ParseExactToUtcTime(timeZone, text, format, formatProvider, styles).ToLocalTime();
        }

        /// <summary>
        /// Tries to parses the specified text in the specified timezone
        /// </summary>
        /// <param name="timeZone">Time zone for which the text date is specified</param>
        /// <param name="text">Date/time text to be parsed</param>
        /// <param name="format">Date time format</param>
        /// <param name="localTime">Parsed time</param>
        /// <param name="formatProvider">Formatting culture</param>
        /// <param name="styles">DateTime styles</param>
        /// <returns>True if the text could be parsed. False otherwise</returns>
        public static bool TryParseExactToLocalTime(this TimeZoneInfo timeZone, string text, string format, out DateTime localTime, IFormatProvider formatProvider = null, DateTimeStyles styles = DateTimeStyles.None)
        {
            if (TryParseExactToUtcTime(timeZone, text, format, out localTime, formatProvider, styles))
            {
                localTime = localTime.ToLocalTime();
                return true;
            }
            return false;
        }

        /// <summary>
        /// Parses the specified text in the specified timezone
        /// </summary>
        /// <param name="timeZone">Time zone for which the text date is specified</param>
        /// <param name="text">Date/time text to be parsed</param>
        /// <param name="formats">DateTime formats to try</param>
        /// <param name="formatProvider">Formatting culture</param>
        /// <param name="styles">DateTime styles</param>
        /// <returns>DateTime object in Local co-ordinates</returns>
        public static DateTime ParseExactToLocalTime(this TimeZoneInfo timeZone, string text, string[] formats, IFormatProvider formatProvider = null, DateTimeStyles styles = DateTimeStyles.None)
        {
            return ParseExactToUtcTime(timeZone, text, formats, formatProvider, styles).ToLocalTime();
        }

        /// <summary>
        /// Tries to parses the specified text in the specified timezone
        /// </summary>
        /// <param name="timeZone">Time zone for which the text date is specified</param>
        /// <param name="text">Date/time text to be parsed</param>
        /// <param name="formats">Date time formats to try</param>
        /// <param name="localTime">Parsed time</param>
        /// <param name="formatProvider">Formatting culture</param>
        /// <param name="styles">DateTime styles</param>
        /// <returns>True if the text could be parsed. False otherwise</returns>
        public static bool TryParseExactToLocalTime(this TimeZoneInfo timeZone, string text, string[] formats, out DateTime localTime, IFormatProvider formatProvider = null, DateTimeStyles styles = DateTimeStyles.None)
        {
            if (TryParseExactToUtcTime(timeZone, text, formats, out localTime, formatProvider, styles))
            {
                localTime = localTime.ToLocalTime();
                return true;
            }
            return false;
        }

        #endregion

        #endregion
    }
}